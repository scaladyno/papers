\section{Implementation}

A plugin for the Scala compiler takes form as an additional compiler phase which takes as input the AST from the previous phase (\texttt{typer}), traverses and/or transforms it, corresponding to the implemented behaviour, by recursively running through all AST nodes, and passes it on to the next phase (\texttt{patmat}).

In the normal static typer, typing errors which happen on some branches in the AST will propagate through the tree to the root nodes which implies that all parent nodes are also erroneously typed and thus the full program tree will be erroneous and no VM byte code will be generated. To avoid this kind or error propagation we want to intercept the erroneously typed branches and "cut them off"; prune them at a level which is not harmful to the program semantics and the code generation. The newly generated program will compile even if it contains name or type errors. Finally those pruned branches will be replaced by nodes representing Exceptions of type \texttt{ErrorType} which will only be thrown at runtime.

To achieve  this kind of behavior we first need to prevent the compiler-build-in reporter to issue errors because they will break compilation. This can be done by changing the error reporter through reflection such that it issues warnings instead of errors. This conversion is however only done for naming and typing errors and not for errors from other phases, e.g. parsing errors which cannot be fixed by ScalaDyno. While converting those errors to warnings some static feedback can already be given to the programmer at compile time. When the program fails during execution due to such a deferred error, the error message is stated again which is equivalent to the dynamic behaviour.
in an erroneously branch during runtime. The easiest way to do this is to keep a global mapping from positions to error messages which is later used to insert Exception node with the corresponding message into the AST. Those exception messages, in addition to the compiler warning output, will also be very useful debug information.

As our plugin should have the ability to change the AST we extends the existing class \texttt{Transformer} from the New Scala Compiler tools which defines and provides the method \texttt{transform(tree: Tree): Tree} which can be used as a default traverser for the tree nodes which do not need or allow a specific treatment. The other special cases are intercepted and treated differently.

It is also very important to mention that exceptions cannot be thrown at any place in the code. For example is it not allowed to pass an erroneously typed objects as method arguments nor to match on a pattern which is of type ErroType. For this reason ScalaDyno propagates errors declaration to specific levels in the AST where they are safe to be thrown. Such code levels include \texttt{DefTree}s such as class definitions, member definition and value definitions as well as \texttt{pattern match} expressions. As discussed in (theory ref), errors which are related to the same initial error should not generate additional warnings and should reference the root error during runtime failures. This is also achieved implicitly by taking the errors messages generated by the Scala compiler and their corresponding unique positions, saving those in a mapping such that no duplicates can exist.
