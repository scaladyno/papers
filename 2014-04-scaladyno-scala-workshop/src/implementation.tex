\section{Implementation}

A plugin for the Scala compiler is a separate program that can inject one or more compilation phases and alter the compiler options. In the case of ScalaDyno, we inject a single phase that takes as input the AST from the type checker phase (|typer|), traverses and cleans its erronous statements by recursively running through all AST nodes. It also cleans up the symbol table by removing any erronous symbol, namely any symbol whose type is either |ErrorType| or a derivate of it (e.g. |List[ErrorType]|). The final result is a pruned AST containing only references to correct symbols and symbol table which only contains correct symbols.

The normal behavior of the name resolution and type checking phases is to issue errors which prevent further compilation of the program. To achieve our goal of allowing partially correct programs to compile, we first need to prevent the compiler built-in reporter preventing the further compilation. This can be done by changing the error reporter and transforming errors into warnings. This conversion is however only done for naming and typing errors and not for errors from other phases, e.g. parsing errors which cannot be fixed by ScalaDyno. Since errors are converted to warnings, the programmer already receives the normal feedback during compilation, in the form of warnings. During reporting, we also record the errors, which we use to later patch the tree.

In the type checker, typing errors which happen on some branches in the AST propagate outwards until a stable boundary is reached. Examples of stable boundaries are the next statement in a block or the next definition in a class, trait, object or package. In order to clean up the tree, we remove the erronous statements. Yet, as discussed before, we cannot allow the code to execute past an erronous statement. To implement this, we actually replace erronous statements by statements which throw exceptions. The message in the exception is the actual error output by the compiler for that particular part of the tree. This is implemented by matching source positions in the tree with source positions in the error messages. Positions are a mechanism by which the compiler records the position of each AST node in the source code. Errors also have positions attached, allowing their messages to point to the exact lines in the source code that triggered them. Therefore, based on the recorded messages and positions and the tree positions we can safely replace the tree nodes by exception-throwing statements.

There are a number of places where simply replacing an erronous node by a statement doesn't work. Such cases are pattern matches, definitions inside classes, type-defining nodes and annotations. For these cases, we either have special rules which bubble up the statement (in the case of pattern matches) or we issue an error message that we can't properly clean up the tree and abort the compilation. While these errors could be mitigated, the additional complexity significantly burdens the plugin and does not bring significant benefit. Therefore we chose to focus on the most common errors which can easily be cleaned up.

