 \section{Approach}

%   A typical bug-fix scenario includes adding an extra argument in several methods. Doing so manually by modifying the signature can lead to inconsistencies in the code since multiple call sites would need to be updated. In a statically typed language it would be impossible to prototype such a change since it would be rejected by the type checker. In this case it would be desirable to be able to execute only the path in the program relevant to the bug, while ignoring overall consistency until the fix is working correctly.
%
%   When refactoring part of the code which consists for example in changing the signature of a method or a constructor all the corresponding calls which use this changed construct also need to be filled in with default arguments. This however mostly need to be done by hand with require a big effort from the programmer mostly because the given described process might need to be done several time during design iterations. Of course the given problem could be solved by overloading the given function definition but again this creates some unnecessary overhead due to the reason described above.
%
%   Secondly, during refactoring and release preparation, a more static approach is preferrable, to allow the developer to confidently make changes without the risk of breaking the code. For example when refacting part of the code which consists in changing the signature of a method or a constructor all the corresponding calls which use this changed construct also need to be filled in with default arguments. However this needs to be done mostly by hand, thus requiring a big effort from the programmer mostly because the described process might need to be done several times during design iterations. Of course the given problem could be solved by overloading the given function definition but again this creates some unnecessary overhead due to the reasons described above. Hence it would be very useful to be able to execute paths of the program which do not include any of those wrong signatures being called. %In the case where such branches would be traversed.

% \textbf{This is more like explaining how things happened, rather than describing the motivation.}

% Effort has been invested in including dynamic behaviour into statically typed languages such as, for example, in Haskell and Scala. However, most of the approaches require big changes in the compiler and also supporting runtime libraries which slows down both compilation and execution due to the induced overhead. Our idea was to create a very lightweight tool which might not be as extensible and not cover as many cases as other alternatives but which can still be very fast, easy to implement and easy to use. Our choice for the Scala language was based on the fact that, even though this object-oriented, functional programming language has grown into a full real-world software development language, there is still missing an easy solution for fast development and testing. During the project we also wanted to explore other possible solutions such that the core compiler would need the fewest changes. In the beginning we hoped that we could use the recently added trait {\ttfamily Dynamic} in combination with implicit conversion and typed macros. Sadly we quickly needed to notify that implicit conversion do not apply for conversions to Dynamic. This means that implicit conversion won't automatically apply a conversion to a dynamic type whenever no statically correctly typed alternatives are available. Hence we needed to consider a more integrated solution such that we finally implemented a Scala compiler plugin which does the transformation directly on the AST.

Our goal in the ScalaDyno project is create a modified version of the Scala compiler which allows agile development, especially for prototyping breaking changes to the code base. Such breaking changes include adding or removing fields, methods or classes, changing parameter types or referring to non-existing names. In addition to handling such cases, our solution should not change the semantics of correct code: implicits should still be resolved where possible and the performance of the correct parts of the program should not be impacted. Finally, once the prototyping session is over, all the errors should be available to enable developers to prepare the release.

%%TODO: Should this go into the related work section?!?

Several approaches to enabling faster prototyping are currently in use: dynamic languages with checking, reflection and proxies. A dynamic language can be augmented it with type annotations which can then be used to give static feedback at compile time. These annotations would be optional, and the checks would only trigger if both the actual and the expected type are annotated, as the Dart programming language does \cite{dart}. Yet, such approaches are still fundamentally dynamic, and thus allow patterns such as monkey patching and duck typing, which, once used, make the code base impossible to check completely.

A second approach is completely switching to the use of reflection, practically turning a statically typed language such as Java or Scala into a dynamic language. This has been implemented in DuctileJ and DuctileScala \cite{ductilej,ductilescala}. Yet this approach makes heavy use of reflection and is unable to resolve implicits. This makes it unsuitable for our use case, as it introduces significant overheads for correct programs and it potentially prevents correct programs using implicits from running at all.

A third approch is using an proxy technique, such as the |Dynamic| trait in Scala \cite{dynamic} which acts as a proxy that allows rewriting unresolved methods to more general proxies, which can later use reflection to call the correct methods. Such approaches have been used to allow interoperability between Scala and JavaScript \cite{scala-js, greg-js-dsl}, but they are not able to handle all cases necessary for prototyping, notably they require correct name and type resolution to work properly. Unfortunately, in many practical scenarios, once an error has occured, type inference doesn't kick in anymore and is not able to infer the |Dynamic| marker in a value's type, such that methods may be called on it.

In our approach we want to collect the errors during compilation, clean the erroneous parts of the tree and replace them by intstructions to trigger the error messages at runtime. This makes it possible to compile the erroneous tree down to bytecode and execute it correctly up to the first erroneous instruction.
