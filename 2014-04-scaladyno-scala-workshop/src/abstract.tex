\section{Abstract}

%In the academic and the professional community it is agreed on the fact that both statically and dynamically typed languages have both benefits and drawbacks. Statically typed languages reject any code that they cannot prove to be correct. However this inflexible, especially when developers are prototyping incompatible changes to the code.
%On the other hand, dynamically typed languages give the developer more freedom by only performing the necessary checks at runtime, but give rise to code patterns that are impossible to check, such as monkey patching and using duck typing.

%It would be useful to have a programming language that combines the benefits of both static and dynamic typing. Such a language would allow agile development while also offering static guarantees for the final compilation.

%The ScalaDyno compiler plugin allows fast prototyping with the Scala programming language. This in done by deferring compilation errors to runtime and thus allowing byte code generation for partially incorrect programs. This reaps the benefits of static checking with the real-world requirements of fast prototyping and quick debugging.

%% TODO: Add Key insight + contribution
%\textbf{TODO: Add Key insight + contribution}

The ScalaDyno compiler\footnote{\url{https://github.com/scaladyno/scaladyno-plugin}} plugin allows fast prototyping with the Scala programming language, in a way that combines the benefits of both statically and dynamically typed languages. Static name resolution and type checking prevent partially-correct code from being compiled and executed. Yet, allowing programmers to test critical paths in a program without worrying about the consistency of the entire code base is crucial to fast prototying and agile development. This is where ScalaDyno comes in: it allows partially-correct programs to be compiled and executed, while shifting compile-time errors to program runtime.

The key insight in ScalaDyno is that name and type errors affect limited areas of the code, which can be replaced by instructions reproducing the respective errors at runtime. This allows byte code generation and execution for partially correct programs, thus allowing Python or JavaScript-like fast prototyping in Scala. This is all done without sacrificing name resolution, full type checking and optimizations for the correct parts of the code -- only without them getting in the way of code changes. Finally, for release code or sensitive refactorings, runtime errors can be disabled, thus allowing full static name resolution and type checking typical of the Scala compiler.


